1.static 的概念及使用场景.static局部变量的导致的多线程的安全.
	储存位置：静态存储区.生命周期是全局的,伴随着程序的开始和结束.
	作用于：作用全局和局部之分.
	全局变量程序开始就初始化,局部变量首次调用该函数时初始化.
	局部变量的多线程调用是不安全的,在初始化的时候会有一个flag的判断.c98的时候并没有对这个标记lock,c++有对这个部分的保护.

2.进程和线程区别. ui线程可以多个吗.
	进程和线程的主要差别在于它们是不同的操作系统资源管理方式。
	进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。
	线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，
	但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
	
	
3.c++ 多肽的实现原理的几种方式，重载的原理
	在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数
	具体细节 通过虚表实现.

4.tcp/udp区别,
  1.基于连接与无连接
  2.TCP要求系统资源较多，UDP较少； 
  3.UDP程序结构较简单 
  4.流模式（TCP）与数据报模式(UDP); 
  5.TCP保证数据正确性，UDP可能丢包 
  6.TCP保证数据顺序，UDP不保证 
　　
	UDP应用场景：
  1.面向数据报方式
  2.网络数据大多为短消息 
  3.拥有大量Client
  4.对数据安全性无特殊要求
  5.网络负担非常重，但对响应速度要求高

5.tcp粘包

  1.tcp为保证效率，往往等tcp数据到一定量再会发送.
  2.接收方 接收数据不及时,导致数据堆积在接收缓冲区

为了避免粘包现象，可采取以下几种措施：

（1）对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；

（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；

（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。

 

以上提到的三种措施，都有其不足之处。

（1）第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。

（2）第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。

（3）第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。


一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。对这种方法我们进行了实验，证明是高效可行的

5.ipc的集中方法.
  socket;AnonymousPipe;namedpipe;filemap;sharememory;clipped board;mailsolts;dll;wm_copydata.
 
6.http介绍.
	超文本传输协议，是一种建立在TCP上的无状态连接，整个基本的工作流程是客户端发送一个HTTP请求.
	HTTP请求是客户端往服务端发送请求动作，告知服务器自己的要求
	HTTP请求由状态行、请求头、请求正文三部分组成
	
7.调用定位内存踩踏.
	通过gflg 可以定位.appverif.exe 检测 page/stack.
	
8.windows消息机制.post/send的区别.
  getmessage(),translatemessage()#主要讲keydown/keyup转换为wm_char消息 dispatchmessage 到对应的消息层交由对应的winprocedure 处理.
  postmessage：异步的发送到消息队列;sendmessage block的waiting force 该消息执行return.
  
9.多进程sendmsg。执行机制是怎样的。
   一般来说进程是不能访问其他进程你地址.
   copydata底层是通过share_memory 来实现的

10.301重定向与302重定向的区别
　　302重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。
　　301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。